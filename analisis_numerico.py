# -*- coding: utf-8 -*-
"""Analisis numerico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oNH7mRydrHYgA9OMDK3GgtGUntaIgoXC
"""

import numpy as np

# Solicitar al usuario la cantidad de variables en la matriz
n = int(input("¿Cuántas variables deseas en tu matriz?: "))

# Inicializar matrices
MatrizA = np.zeros((n, n))
MatrizB = np.zeros(n)

# Obtener elementos para la Matriz A y la Matriz B
for fila in range(n):
    print(f'\nFila {fila + 1}:')
    for columna in range(n):
        MatrizA[fila, columna] = float(input(f'Ingresa el elemento en la posición ({fila + 1}, {columna + 1}) para la matriz A: '))

    MatrizB[fila] = float(input(f'Ingresa el elemento para la matriz B({fila + 1}): '))

print("\nTu matriz A es:")
print(MatrizA)

print("\nTu matriz B es:")
print(MatrizB)

# Verificar si el elemento en la posición (1,1) de la matriz A es igual a 0
if MatrizA[0, 0] == 0:
    print("El elemento en la posición (1,1) de la matriz A es igual a 0.")
    print("\nCerrando el programa...")
else:
    print("El elemento en la posición (1,1) de la matriz A NO es igual a 0. --> Se puede continuar")

# Hacer las operaciones de eliminación gaussiana con cambio de filas
for i in range(n-1):
    # Verificar y realizar cambio de filas si es necesario
    if MatrizA[i, i] == 0:
        print("Realizando cambio de filas...")
        maxIndex = np.argmax(np.abs(MatrizA[i+1:, i])) + i + 1
        MatrizA[[i, maxIndex], :] = MatrizA[[maxIndex, i], :]
        MatrizB[i], MatrizB[maxIndex] = MatrizB[maxIndex], MatrizB[i]

    for j in range(i+1, n):
        factorElemento = MatrizA[j, i] / MatrizA[i, i]
        MatrizA[j, :] -= factorElemento * MatrizA[i, :]
        MatrizB[j] -= factorElemento * MatrizB[i]

    # Verificar si hay valores infinitos o NaN en MatrizA
    if np.any(np.isinf(MatrizA)) or np.any(np.isnan(MatrizA)):
        print("Error: Se encontraron valores infinitos o NaN en la matriz A.")
        exit()

    # Verificar si hay valores infinitos o NaN en MatrizB
    if np.any(np.isinf(MatrizB)) or np.any(np.isnan(MatrizB)):
        print("Error: Se encontraron valores infinitos o NaN en la matriz B.")
        exit()

# Verificar si hay valores infinitos o NaN en MatrizA después de las operaciones
if np.any(np.isinf(MatrizA)) or np.any(np.isnan(MatrizA)):
    print("Error: Se encontraron valores infinitos o NaN en la matriz A después de las operaciones.")
    exit()

# Verificar si hay valores infinitos o NaN en MatrizB después de las operaciones
if np.any(np.isinf(MatrizB)) or np.any(np.isnan(MatrizB)):
    print("Error: Se encontraron valores infinitos o NaN en la matriz B después de las operaciones.")
    exit()

print("\nMatriz A después de las operaciones:")
print(MatrizA)

print("\nMatriz B después de las operaciones:")
print(MatrizB)

# Resolver el sistema de ecuaciones mediante sustitución hacia atrás
solucion = np.zeros(n)

for i in range(n-1, -1, -1):
    solucion[i] = MatrizB[i] / MatrizA[i, i]
    for j in range(i-1, -1, -1):
        MatrizB[j] -= MatrizA[j, i] * solucion[i]

# Verificar si hay valores infinitos o NaN en la solución
if np.any(np.isinf(solucion)) or np.any(np.isnan(solucion)):
    print("Error: Se encontraron valores infinitos o NaN en la solución del sistema de ecuaciones.")
    exit()

print("\nLa solución del sistema de ecuaciones es:")
print(solucion)

"""#Jacobi

"""

import numpy as np
n = int(input("¿Cuántas variables deseas en tu matriz?: "))

# Inicializar matrices
MatrizA = np.zeros((n, n))
MatrizB = np.zeros((n,1))

# Obtener elementos para la Matriz A y la Matriz B
for fila in range(n):
    print(f'\nFila {fila + 1}:')
    for columna in range(n):
        MatrizA[fila, columna] = float(input(f'Ingresa el elemento en la posición ({fila + 1}, {columna + 1}) para la matriz A: '))

    MatrizB[fila] = float(input(f'Ingresa el elemento para la matriz B({fila + 1}): '))
2
print("\nTu matriz A es:")
print(MatrizA)

print("\nTu matriz B es:")
print(MatrizB)

# MatrizJ = np.concatenate((MatrizA,MatrizB),axis=1)
# print("\nTu matriz J es:")
# print(MatrizJ)

tolerancia = 1e-6
x = np.zeros(n)
error = 1
while error>tolerancia:
  x_antiguo = np.copy(x)
  for i in range(n):
    suma = np.dot(MatrizA[i, :i], x_antiguo[:i]) + np.dot(MatrizA[i, i+1:], x_antiguo[i+1:])
    x[i] = (MatrizB[i, 0] - suma) / MatrizA[i, i]

  error = np.linalg.norm(x - x_antiguo, ord=np.inf)

print(f"\nLa solución luego de converger es de:")
print(x)

"""# Seidel"""

import numpy as np
n = int(input("¿Cuántas variables deseas en tu matriz?: "))

# Inicializar matrices
MatrizA = np.zeros((n, n))
MatrizB = np.zeros((n,1))

# Obtener elementos para la Matriz A y la Matriz B
for fila in range(n):
    print(f'\nFila {fila + 1}:')
    for columna in range(n):
        MatrizA[fila, columna] = float(input(f'Ingresa el elemento en la posición ({fila + 1}, {columna + 1}) para la matriz A: '))

    MatrizB[fila] = float(input(f'Ingresa el elemento para la matriz B({fila + 1}): '))
2
print("\nTu matriz A es:")
print(MatrizA)

print("\nTu matriz B es:")
print(MatrizB)

tolerancia = 1e-6
x = np.zeros(n)
error = 1

def DiagonalDominante(Matriz):

  n = len(Matriz)
  for i in range(n):

    suma = 0
    for j in range(n):

      if i == j:
        continue

      suma += abs(Matriz[i][j])

    if(suma > abs(Matriz[i][i])):
      return False

  return True

if DiagonalDominante(MatrizA):
    print("La matriz A es diagonalmente dominante.")
else:
    print("La matriz A no es diagonalmente dominante.")

tolerancia = 1e-6
x = np.zeros(n)
error = 1

while error > tolerancia:
  x_antiguo = np.copy(x)
  for i in range(n):
    suma =0
    for j in range(n):

      if i != j:
        suma += MatrizA[i][j] * x[j]

    x[i] = (MatrizB[i,0] - suma) / MatrizA[i][i]
    error = np.linalg.norm(x - x_antiguo)



print(f"\nLa solución luego de converger es de:")
print(x)

import numpy as np

def DiagonalDominante(Matriz):

  n = len(Matriz)
  for i in range(n):

    suma = 0
    for j in range(n):

      if i == j:
        continue

      suma += abs(Matriz[i][j])

    if(suma > abs(Matriz[i][i])):
      return False

  return True

def isPositiveDefinite(Matriz):
    # Check if the matrix is symmetric
    if not np.allclose(Matriz, Matriz.T):
        return False

    # Check if all eigenvalues are positive
    eigenvalues = np.linalg.eigvals(Matriz)
    if np.all(eigenvalues > 0):
        return True
    else:
        return False



def Calcular_Tj(matriz):
  n = len(matriz)
  Tj = np.zeros((n,n))
  for i in range(n):
    Aii=matriz[i][i]
    for j in range(n):
      if i != j:
        Tj[i][j] = -(matriz[i][j]/Aii)

  return Tj

def calcularW(Tj):
  eig_vals = np.linalg.eigvals(Tj)
  max_val = np.max(eig_vals)
  w = 2/(1+np.sqrt(1-max_val**2))
  return w

def SOR(MatrizA, MatrizB, w):
    n = len(MatrizA)
    tolerancia = 1e-6
    x = np.zeros(n)
    error = float('inf')

    while error > tolerancia:
        x_antiguo = np.copy(x)
        for i in range(n):
            suma = 0
            for j in range(n):
                if i != j:
                    suma += MatrizA[i][j] * x[j]

            x[i] = (w * ((MatrizB[i, 0] - suma) / MatrizA[i][i])) + (1 - w) * x_antiguo[i]

        error = np.linalg.norm(x - x_antiguo)

    return x

matrizPrueba = np.array([[10, 5, 0,0], [5, 10, -4,0], [0, -4, 8,-1], [0, 0, -1,5]])
MatrizB = np.array([[6], [25], [-11],[-11]])

# matrizPrueba = np.array([[3, -2, 1], [3, 6, 2], [3, 3, 7]])
# MatrizB = np.array([[1], [0], [4]])

if DiagonalDominante(matrizPrueba):
    print("La matriz A es diagonalmente dominante.")
else:
    print("La matriz A no es diagonalmente dominante.")

if isPositiveDefinite(matrizPrueba):
    print("La matriz es positiva definida.")
else:
    print("La matriz no es positiva definida.")


w = calcularW(Calcular_Tj(matrizPrueba))
solucion = SOR(matrizPrueba, MatrizB, w)

print("Solución utilizando SOR:")
print(solucion)

